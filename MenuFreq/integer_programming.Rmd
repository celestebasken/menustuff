---
title: "integer_programming"
author: "Celeste x Chat GPT"
date: "2026-02-16"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Part 0: Current menu freq figures

```{r}
library(dplyr)
library(ggplot2)
library(stringr)

optimization <- read.csv("optimization_data.csv", stringsAsFactors = FALSE)

# If your cut name column isn't Ingredient, change this:
cut_col <- "Ingredient"

# Folder for outputs
dir.create("figures_menu_freq", showWarnings = FALSE)

meat_colors <- c(
  "Beef" = "#C00000",      # deep red
  "Pork" = "#F4A3B4",      # soft pink
  "Chicken" = "#F4C430",   # warm yellow
  "Fish" = "#1F78B4",      # blue
  "Turkey" = "#E8C3A0",    # light tan
  "Shellfish" = "#00008B" # darker blue
)


# Make one plot per Category
categories <- sort(unique(optimization$Category))

for (cat in categories) {

  df_cat <- optimization %>%
    filter(Category == cat, Menu_freq_f25 > 0) %>%
    mutate(cut = .data[[cut_col]]) %>%
    arrange(Menu_freq_f25)

  p <- ggplot(df_cat, aes(x = Menu_freq_f25,
                        y = reorder(cut, Menu_freq_f25),
                        fill = Category)) +
  geom_col() +
  scale_fill_manual(values = meat_colors) +
  labs(
    title = paste0("Number of times that each ", cat, " ingredient was in the Center Plate dish"),
    x = "Number of times in Fall 2025 4-week menu cycle",
    y = "Ingredient"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")


  ggsave(
    filename = file.path("figures_menu_freq", paste0("baseline_", str_replace_all(cat, "\\s+", "_"), ".png")),
    plot = p, width = 12, height = 7, dpi = 300
  )
}

```

## Part 1: Optimization Scenario #1

### The optimization 1A

```{r}

library(lpSolve)

x0 <- optimization$Menu_freq_f25
n  <- nrow(optimization)

meals_served <- sum(x0)

# Lower bound 
reduction <- 0.5
lower <- ceiling(x0 * reduction)

# Upper bound 
max_multiplier <- 1.5
upper <- floor(x0 * max_multiplier)

price <- optimization$Avg_price_lb
ghg   <- optimization$Conventional_GHG_per_lb

sus_flag <- ifelse(tolower(optimization$Default_sus) %in% c("yes","y","true","1","Yes"), 1, 0)
sus_price <- price * sus_flag

# ---- Constraint matrix ----
# 1) Maintain total meals: sum(x) = meals_served
A <- matrix(1, nrow = 1, ncol = n)
dir <- "="
rhs <- meals_served

# 2) Lower bounds: x_i >= lower_i  ->  I x >= lower
A <- rbind(A, diag(n))
dir <- c(dir, rep(">=", n))
rhs <- c(rhs, lower)

# 3) Optional upper bounds: x_i <= upper_i -> I x <= upper (only for non-NA uppers)
if (any(!is.na(upper))) {
  idx <- which(!is.na(upper))
  A <- rbind(A, diag(n)[idx, , drop = FALSE])
  dir <- c(dir, rep("<=", length(idx)))
  rhs <- c(rhs, upper[idx])
}

sol1 <- lp(
  direction = "min",
  objective.in = price,
  const.mat = A,
  const.dir = dir,
  const.rhs = rhs,
  all.int = TRUE
)

sol1$status  # 0 means success
x1 <- sol1$solution
opt_cost <- sum(price * x1)

sol1 <- lp(
  direction = "min",
  objective.in = price,
  const.mat = A,
  const.dir = dir,
  const.rhs = rhs,
  all.int = TRUE
)

sol1$status  # 0 means success
x1 <- sol1$solution
opt_cost <- sum(price * x1)

cost_slack <- 0.001  # 0.1%

A2   <- rbind(A, price)
dir2 <- c(dir, "<=")
rhs2 <- c(rhs, opt_cost * (1 + cost_slack))

sol2 <- lp(
  direction = "max",
  objective.in = sus_price,
  const.mat = A2,
  const.dir = dir2,
  const.rhs = rhs2,
  all.int = TRUE
)

sol2$status
x2 <- sol2$solution
opt_sus <- sum(sus_price * x2)

sus_slack <- 0.0  # require best sustainable spend found in stage 2

A3   <- rbind(A2, sus_price)
dir3 <- c(dir2, ">=")
rhs3 <- c(rhs2, opt_sus * (1 - sus_slack))

sol3 <- lp(
  direction = "min",
  objective.in = ghg,
  const.mat = A3,
  const.dir = dir3,
  const.rhs = rhs3,
  all.int = TRUE
)

sol3$status
x3 <- sol3$solution

summ <- function(x) {
  total_cost <- sum(price * x)
  sus_spend  <- sum(sus_price * x)
  sus_pct    <- if (total_cost > 0) sus_spend / total_cost else NA_real_
  total_ghg  <- sum(ghg * x)
  c(meals = sum(x), total_cost = total_cost, sus_spend = sus_spend, sus_pct = sus_pct, total_ghg = total_ghg)
}

rbind(
  baseline = summ(x0),
  stage1_min_cost = summ(x1),
  stage2_max_sus_given_cost = summ(x2),
  stage3_min_ghg_given_cost_sus = summ(x3)
)

```
```{r}

# Add optimized frequencies to the dataframe
optimization$freq_baseline <- optimization$Menu_freq_f25
optimization$freq_opt_costcut <- x3
optimization$delta_costcut <- optimization$freq_opt_costcut - optimization$freq_baseline

# Quick checks
sum(optimization$freq_baseline)
sum(optimization$freq_opt_costcut)

# Biggest decreases
optimization[order(optimization$delta_costcut), 
             c("Category","Ingredient","freq_baseline","freq_opt_costcut","delta_costcut",
               "Avg_price_lb","Default_sus","Conventional_GHG_per_lb")][1:20, ]

# Biggest increases
optimization[order(-optimization$delta_costcut), 
             c("Category","Ingredient","freq_baseline","freq_opt_costcut","delta_costcut",
               "Avg_price_lb","Default_sus","Conventional_GHG_per_lb")][1:20, ]

library(dplyr)

category_totals_costcut <- optimization %>%
  group_by(Category) %>%
  summarise(
    baseline_meals = sum(freq_baseline, na.rm = TRUE),
    opt_meals = sum(freq_opt_costcut, na.rm = TRUE),
    delta_meals = sum(delta_costcut, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(opt_meals))

category_totals_costcut

category_totals_costcut <- category_totals_costcut %>%
  mutate(
    baseline_share = baseline_meals / sum(baseline_meals),
    opt_share = opt_meals / sum(opt_meals)
  )

category_totals_costcut


```

### Comparison figures

```{r}

library(tidyr)

dir.create("figures_menu_freq_compare", showWarnings = FALSE)

scenario_col <- "freq_opt_costcut"   # <- change if your Scenario #1 column name differs

for (cat in categories) {

  df_cat <- optimization %>%
    filter(Category == cat) %>%
    mutate(cut = .data[[cut_col]]) %>%
    select(Category, cut,
           baseline = Menu_freq_f25,
           scenario1 = .data[[scenario_col]]) %>%
    pivot_longer(cols = c(baseline, scenario1),
                 names_to = "scenario",
                 values_to = "freq") %>%
    filter(freq > 0) %>%
    group_by(cut) %>%
    mutate(order_key = max(freq, na.rm = TRUE)) %>%   # order cuts by max of the two scenarios
    ungroup() %>%
    mutate(cut = reorder(cut, order_key))

  p <- ggplot(df_cat, aes(x = freq, y = cut, fill = scenario)) +
    geom_col(position = position_dodge(width = 0.8), width = 0.75) +
    labs(
      title = paste0(cat, " center-plate frequency: Baseline vs Scenario #1"),
      x = "Number of times in Fall 2025 4-week menu cycle",
      y = "Ingredient",
      fill = ""
    ) +
    theme_minimal(base_size = 14)

  ggsave(
    filename = file.path("figures_menu_freq_compare", paste0("compare_", str_replace_all(cat, "\\s+", "_"), ".png")),
    plot = p, width = 12, height = 7, dpi = 300
  )
}


```

### Scenario 1B
I realized that I'm ultimately optimizing GHG above sustainability, which I don't want to do, so 1B is an attempt to remedy that

```{r}

# --------- tuning knobs ----------
cost_slack <- 0.001  # allow +0.1% cost from min-cost solution so other objectives can move
ghg_slack  <- 0.0    # allow slight relaxation from best GHG before optimizing sustainability (e.g., 0.001)

# ============================================================
# Stage 1: Minimize cost (with your bounds + meal constraint)
# ============================================================
sol1b_stage1 <- lp(
  direction = "min",
  objective.in = price,
  const.mat = A,
  const.dir = dir,
  const.rhs = rhs,
  all.int = TRUE
)
stopifnot(sol1b_stage1$status == 0)

x1b_cost <- sol1b_stage1$solution
opt_cost_1b <- sum(price * x1b_cost)

# Add cost cap so later stages stay essentially min-cost
A_costcap   <- rbind(A, price)
dir_costcap <- c(dir, "<=")
rhs_costcap <- c(rhs, opt_cost_1b * (1 + cost_slack))

# ============================================================
# Stage 2: Minimize GHG subject to near-min-cost
# ============================================================
sol1b_stage2 <- lp(
  direction = "min",
  objective.in = ghg,
  const.mat = A_costcap,
  const.dir = dir_costcap,
  const.rhs = rhs_costcap,
  all.int = TRUE
)
stopifnot(sol1b_stage2$status == 0)

x1b_ghg <- sol1b_stage2$solution
opt_ghg_1b <- sum(ghg * x1b_ghg)

# Add GHG floor/cap so stage 3 keeps the best (or near-best) GHG found
# ghg %*% x <= opt_ghg * (1 + ghg_slack)
A_ghgcap   <- rbind(A_costcap, ghg)
dir_ghgcap <- c(dir_costcap, "<=")
rhs_ghgcap <- c(rhs_costcap, opt_ghg_1b * (1 + ghg_slack))

# ============================================================
# Stage 3: Maximize sustainable spend subject to near-min-cost + near-min-GHG
# ============================================================
sol1b_stage3 <- lp(
  direction = "max",
  objective.in = sus_price,
  const.mat = A_ghgcap,
  const.dir = dir_ghgcap,
  const.rhs = rhs_ghgcap,
  all.int = TRUE
)
stopifnot(sol1b_stage3$status == 0)

x1b_final <- sol1b_stage3$solution

# ============================================================
# Summaries + attach results
# ============================================================
summ <- function(x) {
  total_cost <- sum(price * x)
  sus_spend  <- sum(sus_price * x)
  sus_pct    <- if (total_cost > 0) sus_spend / total_cost else NA_real_
  total_ghg  <- sum(ghg * x)
  c(meals = sum(x), total_cost = total_cost, sus_spend = sus_spend, sus_pct = sus_pct, total_ghg = total_ghg)
}

scenario_1b_table <- rbind(
  baseline = summ(x0),
  s1b_stage1_min_cost = summ(x1b_cost),
  s1b_stage2_min_ghg_given_cost = summ(x1b_ghg),
  s1b_stage3_max_sus_given_cost_ghg = summ(x1b_final)
)

print(scenario_1b_table)

# Add to dataframe
optimization$freq_opt_s1b <- x1b_final
optimization$delta_s1b <- optimization$freq_opt_s1b - optimization$Menu_freq_f25

```
Yeah this is worse-- lol

## Part 2: Scenario #2

```{r}

# ---- baseline totals ----
x0 <- optimization$Menu_freq_f25
baseline_cost <- sum(price * x0)

# Tuning knobs
# (Usually you keep cost_slack = 0 for "no increase", but you can allow tiny rounding wiggle.)
cost_slack <- 0.0   # 0 means cost must be <= baseline_cost exactly
sus_slack  <- 0.0   # 0 means keep the best sustainable spend in stage 3 (tight)

# ============================================================
# Constraint: cost cannot increase
# ============================================================
A_costcap   <- rbind(A, price)
dir_costcap <- c(dir, "<=")
rhs_costcap <- c(rhs, baseline_cost * (1 + cost_slack))

# ============================================================
# Stage 2.1: Maximize sustainability under cost cap
# ============================================================
sol2_stage1 <- lp(
  direction = "max",
  objective.in = sus_price,
  const.mat = A_costcap,
  const.dir = dir_costcap,
  const.rhs = rhs_costcap,
  all.int = TRUE
)

if (sol2_stage1$status != 0) {
  stop("Scenario 2 Stage 1 infeasible. Try relaxing reduction/upper bounds or set cost_slack to a small value (e.g., 0.001).")
}

x2_sus <- sol2_stage1$solution
opt_sus_2 <- sum(sus_price * x2_sus)

# ============================================================
# Stage 2.2: Minimize GHG, while keeping sustainability at (near) optimum
# ============================================================
A_susfloor   <- rbind(A_costcap, sus_price)
dir_susfloor <- c(dir_costcap, ">=")
rhs_susfloor <- c(rhs_costcap, opt_sus_2 * (1 - sus_slack))

sol2_stage2 <- lp(
  direction = "min",
  objective.in = ghg,
  const.mat = A_susfloor,
  const.dir = dir_susfloor,
  const.rhs = rhs_susfloor,
  all.int = TRUE
)

if (sol2_stage2$status != 0) {
  stop("Scenario 2 Stage 2 infeasible. Try setting sus_slack to a small value (e.g., 0.001 or 0.01).")
}

x2_final <- sol2_stage2$solution

# ============================================================
# Summaries
# ============================================================
summ <- function(x) {
  total_cost <- sum(price * x)
  sus_spend  <- sum(sus_price * x)
  sus_pct    <- if (total_cost > 0) sus_spend / total_cost else NA_real_
  total_ghg  <- sum(ghg * x)
  c(meals = sum(x), total_cost = total_cost, sus_spend = sus_spend, sus_pct = sus_pct, total_ghg = total_ghg)
}

scenario_2_table <- rbind(
  baseline = summ(x0),
  s2_stage1_max_sus_no_cost_increase = summ(x2_sus),
  s2_stage2_min_ghg_given_cost_and_sus = summ(x2_final)
)

print(scenario_2_table)

# ============================================================
# Attach Scenario 2 frequencies to your dataframe
# ============================================================
optimization$freq_opt_s2 <- x2_final
optimization$delta_s2 <- optimization$freq_opt_s2 - optimization$Menu_freq_f25

```
```{r}

# If you didn't already set these:
optimization <- optimization %>%
  mutate(
    freq_baseline = Menu_freq_f25,
    delta_s2 = freq_opt_s2 - Menu_freq_f25
  )

category_totals_s2 <- optimization %>%
  group_by(Category) %>%
  summarise(
    baseline_meals = sum(freq_baseline, na.rm = TRUE),
    opt_meals_s2   = sum(freq_opt_s2, na.rm = TRUE),
    delta_meals_s2 = sum(delta_s2, na.rm = TRUE),
    baseline_share = baseline_meals / sum(freq_baseline, na.rm = TRUE),
    opt_share_s2   = opt_meals_s2 / sum(freq_opt_s2, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(opt_meals_s2))

category_totals_s2


```


```{r}
#download these solutions

write.csv(optimization, file = "optimization_including_scenario2.csv", row.names = FALSE)


```


