---
title: "integer_programming"
author: "Celeste x Chat GPT"
date: "2026-02-16"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Part 0: Current menu freq figures

```{r}
library(dplyr)
library(ggplot2)
library(stringr)

optimization <- read.csv("optimization_data.csv", stringsAsFactors = FALSE)

# If your cut name column isn't Ingredient, change this:
cut_col <- "Ingredient"

# Folder for outputs
dir.create("figures_menu_freq", showWarnings = FALSE)

meat_colors <- c(
  "Beef" = "#C00000",      # deep red
  "Pork" = "#F4A3B4",      # soft pink
  "Chicken" = "#F4C430",   # warm yellow
  "Fish" = "#1F78B4",      # blue
  "Turkey" = "#E8C3A0",    # light tan
  "Shellfish" = "#00008B" # darker blue
)


# Make one plot per Category
categories <- sort(unique(optimization$Category))

for (cat in categories) {

  df_cat <- optimization %>%
    filter(Category == cat, Menu_freq_f25 > 0) %>%
    mutate(cut = .data[[cut_col]]) %>%
    arrange(Menu_freq_f25)

  p <- ggplot(df_cat, aes(x = Menu_freq_f25,
                        y = reorder(cut, Menu_freq_f25),
                        fill = Category)) +
  geom_col() +
  scale_fill_manual(values = meat_colors) +
  labs(
    title = paste0("Number of times that each ", cat, " ingredient was in the Center Plate dish"),
    x = "Number of times in Fall 2025 4-week menu cycle",
    y = "Ingredient"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")


  ggsave(
    filename = file.path("figures_menu_freq", paste0("baseline_", str_replace_all(cat, "\\s+", "_"), ".png")),
    plot = p, width = 12, height = 7, dpi = 300
  )
}

```

## Part 1: Optimization Scenario #1

### The optimization 1A

```{r}

library(lpSolve)

x0 <- optimization$Menu_freq_f25
n  <- nrow(optimization)

meals_served <- sum(x0)

# Lower bound 
reduction <- 0.5
lower <- ceiling(x0 * reduction)

# Upper bound 
max_multiplier <- 1.5
upper <- floor(x0 * max_multiplier)

price <- optimization$Avg_price_lb
ghg   <- optimization$Conventional_GHG_per_lb

sus_flag <- ifelse(tolower(optimization$Default_sus) %in% c("yes","y","true","1","Yes"), 1, 0)
sus_price <- price * sus_flag

# ---- Constraint matrix ----
# 1) Maintain total meals: sum(x) = meals_served
A <- matrix(1, nrow = 1, ncol = n)
dir <- "="
rhs <- meals_served

# 2) Lower bounds: x_i >= lower_i  ->  I x >= lower
A <- rbind(A, diag(n))
dir <- c(dir, rep(">=", n))
rhs <- c(rhs, lower)

# 3) Optional upper bounds: x_i <= upper_i -> I x <= upper (only for non-NA uppers)
if (any(!is.na(upper))) {
  idx <- which(!is.na(upper))
  A <- rbind(A, diag(n)[idx, , drop = FALSE])
  dir <- c(dir, rep("<=", length(idx)))
  rhs <- c(rhs, upper[idx])
}

sol1 <- lp(
  direction = "min",
  objective.in = price,
  const.mat = A,
  const.dir = dir,
  const.rhs = rhs,
  all.int = TRUE
)

sol1$status  # 0 means success
x1 <- sol1$solution
opt_cost <- sum(price * x1)

sol1 <- lp(
  direction = "min",
  objective.in = price,
  const.mat = A,
  const.dir = dir,
  const.rhs = rhs,
  all.int = TRUE
)

sol1$status  # 0 means success
x1 <- sol1$solution
opt_cost <- sum(price * x1)

cost_slack <- 0.001  # 0.1%

A2   <- rbind(A, price)
dir2 <- c(dir, "<=")
rhs2 <- c(rhs, opt_cost * (1 + cost_slack))

sol2 <- lp(
  direction = "max",
  objective.in = sus_price,
  const.mat = A2,
  const.dir = dir2,
  const.rhs = rhs2,
  all.int = TRUE
)

sol2$status
x2 <- sol2$solution
opt_sus <- sum(sus_price * x2)

sus_slack <- 0.0  # require best sustainable spend found in stage 2

A3   <- rbind(A2, sus_price)
dir3 <- c(dir2, ">=")
rhs3 <- c(rhs2, opt_sus * (1 - sus_slack))

sol3 <- lp(
  direction = "min",
  objective.in = ghg,
  const.mat = A3,
  const.dir = dir3,
  const.rhs = rhs3,
  all.int = TRUE
)

sol3$status
x3 <- sol3$solution

summ <- function(x) {
  total_cost <- sum(price * x)
  sus_spend  <- sum(sus_price * x)
  sus_pct    <- if (total_cost > 0) sus_spend / total_cost else NA_real_
  total_ghg  <- sum(ghg * x)
  c(meals = sum(x), total_cost = total_cost, sus_spend = sus_spend, sus_pct = sus_pct, total_ghg = total_ghg)
}

rbind(
  baseline = summ(x0),
  stage1_min_cost = summ(x1),
  stage2_max_sus_given_cost = summ(x2),
  stage3_min_ghg_given_cost_sus = summ(x3)
)

```
```{r}

# Add optimized frequencies to the dataframe
optimization$freq_baseline <- optimization$Menu_freq_f25
optimization$freq_opt_costcut <- x3
optimization$delta_costcut <- optimization$freq_opt_costcut - optimization$freq_baseline

# Quick checks
sum(optimization$freq_baseline)
sum(optimization$freq_opt_costcut)

# Biggest decreases
optimization[order(optimization$delta_costcut), 
             c("Category","Ingredient","freq_baseline","freq_opt_costcut","delta_costcut",
               "Avg_price_lb","Default_sus","Conventional_GHG_per_lb")][1:20, ]

# Biggest increases
optimization[order(-optimization$delta_costcut), 
             c("Category","Ingredient","freq_baseline","freq_opt_costcut","delta_costcut",
               "Avg_price_lb","Default_sus","Conventional_GHG_per_lb")][1:20, ]

library(dplyr)

category_totals_costcut <- optimization %>%
  group_by(Category) %>%
  summarise(
    baseline_meals = sum(freq_baseline, na.rm = TRUE),
    opt_meals = sum(freq_opt_costcut, na.rm = TRUE),
    delta_meals = sum(delta_costcut, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(opt_meals))

category_totals_costcut

category_totals_costcut <- category_totals_costcut %>%
  mutate(
    baseline_share = baseline_meals / sum(baseline_meals),
    opt_share = opt_meals / sum(opt_meals)
  )

category_totals_costcut


```

### Comparison figures

```{r}

library(tidyr)

dir.create("figures_menu_freq_compare", showWarnings = FALSE)

scenario_col <- "freq_opt_costcut"   # <- change if your Scenario #1 column name differs

for (cat in categories) {

  df_cat <- optimization %>%
    filter(Category == cat) %>%
    mutate(cut = .data[[cut_col]]) %>%
    select(Category, cut,
           baseline = Menu_freq_f25,
           scenario1 = .data[[scenario_col]]) %>%
    pivot_longer(cols = c(baseline, scenario1),
                 names_to = "scenario",
                 values_to = "freq") %>%
    filter(freq > 0) %>%
    group_by(cut) %>%
    mutate(order_key = max(freq, na.rm = TRUE)) %>%   # order cuts by max of the two scenarios
    ungroup() %>%
    mutate(cut = reorder(cut, order_key))

  p <- ggplot(df_cat, aes(x = freq, y = cut, fill = scenario)) +
    geom_col(position = position_dodge(width = 0.8), width = 0.75) +
    labs(
      title = paste0(cat, " center-plate frequency: Baseline vs Scenario #1"),
      x = "Number of times in Fall 2025 4-week menu cycle",
      y = "Ingredient",
      fill = ""
    ) +
    theme_minimal(base_size = 14)

  ggsave(
    filename = file.path("figures_menu_freq_compare", paste0("compare_", str_replace_all(cat, "\\s+", "_"), ".png")),
    plot = p, width = 12, height = 7, dpi = 300
  )
}


```

### Scenario 1B
I realized that I'm ultimately optimizing GHG above sustainability, which I don't want to do, so 1B is an attempt to remedy that

```{r}

# --------- tuning knobs ----------
cost_slack <- 0.001  # allow +0.1% cost from min-cost solution so other objectives can move
ghg_slack  <- 0.0    # allow slight relaxation from best GHG before optimizing sustainability (e.g., 0.001)

# ============================================================
# Stage 1: Minimize cost (with your bounds + meal constraint)
# ============================================================
sol1b_stage1 <- lp(
  direction = "min",
  objective.in = price,
  const.mat = A,
  const.dir = dir,
  const.rhs = rhs,
  all.int = TRUE
)
stopifnot(sol1b_stage1$status == 0)

x1b_cost <- sol1b_stage1$solution
opt_cost_1b <- sum(price * x1b_cost)

# Add cost cap so later stages stay essentially min-cost
A_costcap   <- rbind(A, price)
dir_costcap <- c(dir, "<=")
rhs_costcap <- c(rhs, opt_cost_1b * (1 + cost_slack))

# ============================================================
# Stage 2: Minimize GHG subject to near-min-cost
# ============================================================
sol1b_stage2 <- lp(
  direction = "min",
  objective.in = ghg,
  const.mat = A_costcap,
  const.dir = dir_costcap,
  const.rhs = rhs_costcap,
  all.int = TRUE
)
stopifnot(sol1b_stage2$status == 0)

x1b_ghg <- sol1b_stage2$solution
opt_ghg_1b <- sum(ghg * x1b_ghg)

# Add GHG floor/cap so stage 3 keeps the best (or near-best) GHG found
# ghg %*% x <= opt_ghg * (1 + ghg_slack)
A_ghgcap   <- rbind(A_costcap, ghg)
dir_ghgcap <- c(dir_costcap, "<=")
rhs_ghgcap <- c(rhs_costcap, opt_ghg_1b * (1 + ghg_slack))

# ============================================================
# Stage 3: Maximize sustainable spend subject to near-min-cost + near-min-GHG
# ============================================================
sol1b_stage3 <- lp(
  direction = "max",
  objective.in = sus_price,
  const.mat = A_ghgcap,
  const.dir = dir_ghgcap,
  const.rhs = rhs_ghgcap,
  all.int = TRUE
)
stopifnot(sol1b_stage3$status == 0)

x1b_final <- sol1b_stage3$solution

# ============================================================
# Summaries + attach results
# ============================================================
summ <- function(x) {
  total_cost <- sum(price * x)
  sus_spend  <- sum(sus_price * x)
  sus_pct    <- if (total_cost > 0) sus_spend / total_cost else NA_real_
  total_ghg  <- sum(ghg * x)
  c(meals = sum(x), total_cost = total_cost, sus_spend = sus_spend, sus_pct = sus_pct, total_ghg = total_ghg)
}

scenario_1b_table <- rbind(
  baseline = summ(x0),
  s1b_stage1_min_cost = summ(x1b_cost),
  s1b_stage2_min_ghg_given_cost = summ(x1b_ghg),
  s1b_stage3_max_sus_given_cost_ghg = summ(x1b_final)
)

print(scenario_1b_table)

# Add to dataframe
optimization$freq_opt_s1b <- x1b_final
optimization$delta_s1b <- optimization$freq_opt_s1b - optimization$Menu_freq_f25

```
Yeah this is worse-- lol

## Part 2: Scenario #2
Maximize sustainability! Yay

```{r}

# ---- baseline totals ----
x0 <- optimization$Menu_freq_f25
baseline_cost <- sum(price * x0)

# Tuning knobs
# (Usually you keep cost_slack = 0 for "no increase", but you can allow tiny rounding wiggle.)
cost_slack <- 0.0   # 0 means cost must be <= baseline_cost exactly
sus_slack  <- 0.0   # 0 means keep the best sustainable spend in stage 3 (tight)

# ============================================================
# Constraint: cost cannot increase
# ============================================================
A_costcap   <- rbind(A, price)
dir_costcap <- c(dir, "<=")
rhs_costcap <- c(rhs, baseline_cost * (1 + cost_slack))

# ============================================================
# Stage 2.1: Maximize sustainability under cost cap
# ============================================================
sol2_stage1 <- lp(
  direction = "max",
  objective.in = sus_price,
  const.mat = A_costcap,
  const.dir = dir_costcap,
  const.rhs = rhs_costcap,
  all.int = TRUE
)

if (sol2_stage1$status != 0) {
  stop("Scenario 2 Stage 1 infeasible. Try relaxing reduction/upper bounds or set cost_slack to a small value (e.g., 0.001).")
}

x2_sus <- sol2_stage1$solution
opt_sus_2 <- sum(sus_price * x2_sus)

# ============================================================
# Stage 2.2: Minimize GHG, while keeping sustainability at (near) optimum
# ============================================================
A_susfloor   <- rbind(A_costcap, sus_price)
dir_susfloor <- c(dir_costcap, ">=")
rhs_susfloor <- c(rhs_costcap, opt_sus_2 * (1 - sus_slack))

sol2_stage2 <- lp(
  direction = "min",
  objective.in = ghg,
  const.mat = A_susfloor,
  const.dir = dir_susfloor,
  const.rhs = rhs_susfloor,
  all.int = TRUE
)

if (sol2_stage2$status != 0) {
  stop("Scenario 2 Stage 2 infeasible. Try setting sus_slack to a small value (e.g., 0.001 or 0.01).")
}

x2_final <- sol2_stage2$solution

# ============================================================
# Summaries
# ============================================================
summ <- function(x) {
  total_cost <- sum(price * x)
  sus_spend  <- sum(sus_price * x)
  sus_pct    <- if (total_cost > 0) sus_spend / total_cost else NA_real_
  total_ghg  <- sum(ghg * x)
  c(meals = sum(x), total_cost = total_cost, sus_spend = sus_spend, sus_pct = sus_pct, total_ghg = total_ghg)
}

scenario_2_table <- rbind(
  baseline = summ(x0),
  s2_stage1_max_sus_no_cost_increase = summ(x2_sus),
  s2_stage2_min_ghg_given_cost_and_sus = summ(x2_final)
)

print(scenario_2_table)

# ============================================================
# Attach Scenario 2 frequencies to your dataframe
# ============================================================
optimization$freq_opt_s2 <- x2_final
optimization$delta_s2 <- optimization$freq_opt_s2 - optimization$Menu_freq_f25

```
```{r}

# If you didn't already set these:
optimization <- optimization %>%
  mutate(
    freq_baseline = Menu_freq_f25,
    delta_s2 = freq_opt_s2 - Menu_freq_f25
  )

category_totals_s2 <- optimization %>%
  group_by(Category) %>%
  summarise(
    baseline_meals = sum(freq_baseline, na.rm = TRUE),
    opt_meals_s2   = sum(freq_opt_s2, na.rm = TRUE),
    delta_meals_s2 = sum(delta_s2, na.rm = TRUE),
    baseline_share = baseline_meals / sum(freq_baseline, na.rm = TRUE),
    opt_share_s2   = opt_meals_s2 / sum(freq_opt_s2, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(opt_meals_s2))

category_totals_s2


```


```{r}
#download these solutions

write.csv(optimization, file = "optimization_including_scenario2.csv", row.names = FALSE)

```

## Scenario 3: 
Same as 1b but with caps of 25%

```{r}

# ---- baseline & dimensions ----
x0 <- optimization$Menu_freq_f25
n  <- length(x0)
meals_served <- sum(x0)

# ---- vectors (assumes you already created these) ----
# price <- optimization$Avg_price_lb
# ghg   <- optimization$Conventional_GHG_per_lb
# sus_price <- price * sus_flag   # from earlier (Default_sus-based)

# ---- 25% bounds ----
reduction_25 <- 0.75   # can decrease at most 25%
increase_25  <- 1.25   # can increase at most 25%

lower_25 <- ceiling(x0 * reduction_25)
upper_25 <- floor(x0 * increase_25)

# ---- build constraints: sum meals + lower + upper ----
A <- matrix(1, nrow = 1, ncol = n)
dir <- "="
rhs <- meals_served

# lower bounds: x >= lower_25
A <- rbind(A, diag(n))
dir <- c(dir, rep(">=", n))
rhs <- c(rhs, lower_25)

# upper bounds: x <= upper_25
A <- rbind(A, diag(n))
dir <- c(dir, rep("<=", n))
rhs <- c(rhs, upper_25)

# ---- tuning knobs ----
cost_slack <- 0.001   # allow +0.1% cost beyond minimum so GHG/sus can move (increase if needed)
ghg_slack  <- 0.0     # keep best GHG in stage 3 (set to small >0 if stage3 can't move)

# ============================================================
# Stage 1: Minimize cost
# ============================================================
sol3_stage1 <- lp(
  direction = "min",
  objective.in = price,
  const.mat = A,
  const.dir = dir,
  const.rhs = rhs,
  all.int = TRUE
)

if (sol3_stage1$status != 0) {
  stop("Scenario 3 Stage 1 infeasible. ±25% caps may be too strict.")
}

x3_cost <- sol3_stage1$solution
opt_cost <- sum(price * x3_cost)

# Add cost cap: price %*% x <= opt_cost * (1 + cost_slack)
A_costcap   <- rbind(A, price)
dir_costcap <- c(dir, "<=")
rhs_costcap <- c(rhs, opt_cost * (1 + cost_slack))

# ============================================================
# Stage 2: Minimize GHG given near-min cost
# ============================================================
sol3_stage2 <- lp(
  direction = "min",
  objective.in = ghg,
  const.mat = A_costcap,
  const.dir = dir_costcap,
  const.rhs = rhs_costcap,
  all.int = TRUE
)

if (sol3_stage2$status != 0) {
  stop("Scenario 3 Stage 2 infeasible. Try increasing cost_slack (e.g., 0.01).")
}

x3_ghg <- sol3_stage2$solution
opt_ghg <- sum(ghg * x3_ghg)

# Add GHG cap: ghg %*% x <= opt_ghg * (1 + ghg_slack)
A_ghgcap   <- rbind(A_costcap, ghg)
dir_ghgcap <- c(dir_costcap, "<=")
rhs_ghgcap <- c(rhs_costcap, opt_ghg * (1 + ghg_slack))

# ============================================================
# Stage 3: Maximize sustainable spend given near-min cost + near-min GHG
# ============================================================
sol3_stage3 <- lp(
  direction = "max",
  objective.in = sus_price,
  const.mat = A_ghgcap,
  const.dir = dir_ghgcap,
  const.rhs = rhs_ghgcap,
  all.int = TRUE
)

if (sol3_stage3$status != 0) {
  stop("Scenario 3 Stage 3 infeasible. Try setting ghg_slack to small > 0 (e.g., 0.001 or 0.01).")
}

x3_final <- sol3_stage3$solution

# ============================================================
# Summaries + attach to df
# ============================================================
summ <- function(x) {
  total_cost <- sum(price * x)
  sus_spend  <- sum(sus_price * x)
  sus_pct    <- if (total_cost > 0) sus_spend / total_cost else NA_real_
  total_ghg  <- sum(ghg * x)
  c(meals = sum(x), total_cost = total_cost, sus_spend = sus_spend, sus_pct = sus_pct, total_ghg = total_ghg)
}

scenario_3_table <- rbind(
  baseline = summ(x0),
  s3_stage1_min_cost = summ(x3_cost),
  s3_stage2_min_ghg_given_cost = summ(x3_ghg),
  s3_stage3_max_sus_given_cost_ghg = summ(x3_final)
)

print(scenario_3_table)

# Add scenario 3 frequencies
optimization$freq_opt_s3 <- x3_final
optimization$delta_s3 <- optimization$freq_opt_s3 - optimization$Menu_freq_f25


```
```{r}
#download these solutions

write.csv(optimization, file = "optimization_including_scenario3.csv", row.names = FALSE)

```

```{r}
# Make sure delta exists
optimization <- optimization %>%
  mutate(
    freq_baseline = Menu_freq_f25,
    delta_s3 = freq_opt_s3 - Menu_freq_f25
  )

category_totals_s3 <- optimization %>%
  group_by(Category) %>%
  summarise(
    baseline_meals = sum(freq_baseline, na.rm = TRUE),
    opt_meals_s3   = sum(freq_opt_s3, na.rm = TRUE),
    delta_meals_s3 = sum(delta_s3, na.rm = TRUE),
    baseline_share = baseline_meals / sum(freq_baseline, na.rm = TRUE),
    opt_share_s3   = opt_meals_s3 / sum(freq_opt_s3, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(opt_meals_s3))

category_totals_s3
```

## Scenario 4: Same as 2 but with fish capped

```{r}

# --- baseline ---
x0 <- optimization$Menu_freq_f25
n  <- length(x0)
meals_served <- sum(x0)

# --- make sure Category is clean (prevents “Fish ” vs “Fish”) ---
optimization$Category <- trimws(optimization$Category)

# --- vectors (use your existing ones) ---
# price <- optimization$Avg_price_lb
# ghg   <- optimization$Conventional_GHG_per_lb
# sus_price <- price * sus_flag   # as you defined earlier

# ----------------------------
# 0) Build your usual per-item bounds + total meals constraints
#    (Use whatever bounds you’ve been using; below shows the ±50% version.)
# ----------------------------
reduction <- 0.5         # cannot decrease by more than 50%
max_multiplier <- 1.5    # cannot increase by more than 50%

lower <- ceiling(x0 * reduction)
upper <- floor(x0 * max_multiplier)

A <- matrix(1, nrow = 1, ncol = n)
dir <- "="
rhs <- meals_served

# lower bounds: x >= lower
A <- rbind(A, diag(n))
dir <- c(dir, rep(">=", n))
rhs <- c(rhs, lower)

# upper bounds: x <= upper
A <- rbind(A, diag(n))
dir <- c(dir, rep("<=", n))
rhs <- c(rhs, upper)

# ----------------------------
# 1) Add fish cap: total fish meals <= 1.15 * baseline fish meals
# ----------------------------
# IMPORTANT: adjust these labels to match your data exactly if needed
fish_labels <- c("Fish", "Seafood")

fish_idx <- which(optimization$Category %in% fish_labels)

# If fish_idx is empty, try this more flexible matching:
if (length(fish_idx) == 0) {
  fish_idx <- which(grepl("fish|seafood", tolower(optimization$Category)))
}

if (length(fish_idx) == 0) {
  stop("Could not find Fish rows. Check unique(optimization$Category) and update fish_labels.")
}

baseline_fish_meals <- sum(x0[fish_idx])
fish_cap <- floor(baseline_fish_meals * 1.15)

fish_row <- rep(0, n)
fish_row[fish_idx] <- 1

A_fish   <- rbind(A, fish_row)
dir_fish <- c(dir, "<=")
rhs_fish <- c(rhs, fish_cap)

# ----------------------------
# 2) Scenario 4: cost cannot increase (cap at baseline cost)
# ----------------------------
baseline_cost <- sum(price * x0)

cost_slack <- 0.0  # set to 0.001 if you want a tiny wiggle (0.1%)

A_costcap   <- rbind(A_fish, price)
dir_costcap <- c(dir_fish, "<=")
rhs_costcap <- c(rhs_fish, baseline_cost * (1 + cost_slack))

# ----------------------------
# 3) Stage 1: Maximize sustainability (under cost cap + fish cap + per-item bounds)
# ----------------------------
sol4_stage1 <- lp(
  direction = "max",
  objective.in = sus_price,
  const.mat = A_costcap,
  const.dir = dir_costcap,
  const.rhs = rhs_costcap,
  all.int = TRUE
)

if (sol4_stage1$status != 0) {
  stop("Scenario 4 Stage 1 infeasible. Try: (a) cost_slack <- 0.001, (b) relax bounds, or (c) fish cap too tight.")
}

x4_sus <- sol4_stage1$solution
opt_sus4 <- sum(sus_price * x4_sus)

# ----------------------------
# 4) Stage 2: Minimize GHG while keeping sustainability at (near) optimum
# ----------------------------
sus_slack <- 0.0  # set to 0.005 (0.5%) if Stage 2 becomes infeasible

A_susfloor   <- rbind(A_costcap, sus_price)
dir_susfloor <- c(dir_costcap, ">=")
rhs_susfloor <- c(rhs_costcap, opt_sus4 * (1 - sus_slack))

sol4_stage2 <- lp(
  direction = "min",
  objective.in = ghg,
  const.mat = A_susfloor,
  const.dir = dir_susfloor,
  const.rhs = rhs_susfloor,
  all.int = TRUE
)

if (sol4_stage2$status != 0) {
  stop("Scenario 4 Stage 2 infeasible. Try sus_slack <- 0.005 or 0.01.")
}

x4_final <- sol4_stage2$solution

# ----------------------------
# 5) Summaries + attach results
# ----------------------------
summ <- function(x) {
  total_cost <- sum(price * x)
  sus_spend  <- sum(sus_price * x)
  sus_pct    <- if (total_cost > 0) sus_spend / total_cost else NA_real_
  total_ghg  <- sum(ghg * x)
  fish_meals <- sum(x[fish_idx])
  c(meals = sum(x), total_cost = total_cost, sus_spend = sus_spend, sus_pct = sus_pct,
    total_ghg = total_ghg, fish_meals = fish_meals)
}

scenario_4_table <- rbind(
  baseline = summ(x0),
  s4_stage1_max_sus_no_costinc_fishcap = summ(x4_sus),
  s4_stage2_min_ghg_given_cost_sus_fishcap = summ(x4_final)
)

print(scenario_4_table)

# Attach to dataframe
optimization$freq_opt_s4 <- x4_final
optimization$delta_s4 <- optimization$freq_opt_s4 - optimization$Menu_freq_f25

```
```{r}
#download these solutions

write.csv(optimization, file = "optimization_including_scenario4.csv", row.names = FALSE)

```
